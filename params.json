{"name":"Linux0","tagline":"linux select poll epoll simple study","body":"`linux的I/O复用技术`\r\n\r\n关于select poll epoll的讲解如下：　　　　　\r\n\r\n一．select函数编程   \r\n====\r\n```\r\nint select(int nfds,fd_set*readfd,fd_set*writefd,fd_set*expectd,struct timeval *timeout);\r\n```\r\n函数参数：　　　　　　\r\n\r\n* 参数一：是文件描述符的最大值加一（限制检测文件描述符的范围）    \r\n* 参数二：包含所有因状态变为可读而触发selest函数返回文件描述符    \r\n* 参数三：包含所有因状态变为可写而触发selest函数返回文件描述符   \r\n* 参数四：包含所有因状态发生特殊异常而触发selest函数返回文件描述符     \r\n* 参数五：表示阻塞超时时限\r\n\r\n返回值：     \r\n\r\n    一：当为-1的时候表示出错     \r\n    二：当为0的时候表示超时    \r\n    三：成功的话是一个大于0的整数    \r\n\r\n\r\n注意：最多表示1024个集合（32个long型的 即：long  bits[32];一共1024位）     \r\n\r\nselect函数的应用：\r\n\r\n 主要运用与并发式的服务器端编程\r\n\r\n    其基本思路是： 首先是把要检测的文件描述符加载到fd_set类型的集合中，然后调用select函数检测加载到集合中的文件\r\n描述符是否有（可读，可写，特殊异常）信息，再然后调用FD_ISSET函数判断到底是哪一个文件描述符变成了（可读，可写，特\r\n殊异常）的了。      \r\n\r\n注意：     \r\n  （在每次调用select之前都要对fdset集合进行FD_ZERO（&fdset）操作）；进行清零\r\n\r\n\r\n总结：      \r\n     虽然多线程还有多进程都可以实现并发式服务器端编程，但是相对于select来说其花费的代价太高了，说白了select是以空\r\n间来换取时间的，当然select实现的并发式服务器端编程也是有缺点的，原因是：由于  假设你只有两个客户端在和服务器端交互，\r\n但是你每次都得遍历整个数组（或是链表）来寻找其相应的文件描述符     \r\n\r\n\r\nselect的几大缺点：\r\n\r\n* （1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大    \r\n\r\n* （2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大       \r\n\r\n* （3）select支持的文件描述符数量太小了，默认是1024    \r\n\r\n\r\n其服务器端代码设计如下：\r\n\r\n```c\r\n    struct timeval tv;\r\n    int fds[MAXSIZE];\r\n    memset(fds,-1,sizeof(fds));\r\n    fd_set fdset;\r\n   \r\n    fds[0] = sockfd;\r\n\r\n    while( 1 )\r\n    {\r\n        FD_ZERO(&fdset);\r\n        int i = 0;\r\n        int fdmax = fds[0];\r\n       for( ; i < MAXSIZE; i++ )\r\n        {\r\n            if ( fds[i] != -1 )\r\n            {\r\n                FD_SET(fds[i],&fdset);\r\n                if ( fdmax < fds[i] )\r\n                {\r\n                    fdmax = fds[i];\r\n                }\r\n            }\r\n        }         \r\n        tv.tv_sec = 2;\r\n        tv.tv_usec = 0;\r\n        int res = select( fdmax+1,&fdset,NULL,NULL,&tv);\r\n        assert( res != -1 );\r\n        if ( res == 0 )\r\n        {\r\n            printf(\"timeout\\n\");\r\n        }\r\n        else\r\n        {\r\n            int i = 0; \r\n            for( ; i < MAXSIZE ; i++ )\r\n            {\r\n                if ( fds[i] == -1 )\r\n                {\r\n                    continue;\r\n                }\r\n     if ( FD_ISSET( fds[i], &fdset) )\r\n    {\r\n        if ( fds[i] == sockfd )\r\n        {\r\n         int c = accept(sockfd,(struct sockaddr*)&caddr,&len);\r\n           if ( c >= 0 )\r\n            {\r\n          if ( addfd(c,fds) == 0 ) //把c加载到数组中去\r\n           {\r\n               close(c);\r\n              }                \r\n            }\r\n     }\r\n      else\r\n    {\r\n      char buff[256]= {0};\r\n      int n = read( fds[i],buff,255);\r\n       if ( n  > 0 )\r\n       {\r\n       printf(\"read:%s\\n\",buff);\r\n       write(fds[i],\"OK\",2);\r\n        }\r\n         else if( n == 0 )\r\n          {\r\n            delfd(fds[i],fds);\r\n         } \r\n                        \r\n   }\r\n   }\r\n  }\r\n   \r\n\r\n }\r\n```\r\n\r\n\r\n二．poll函数编程\r\n====\r\n\r\n```c\r\n#include<poll.h>\r\n\r\ntypedef unsigned long int nfds_t;\r\n\r\n\r\nint poll(struct pollfd* fds,nfds_t nfds,int timeout);\r\n\r\nstruct pollfd\r\n{\r\n  int fd;\r\n  short events;\r\n  short revents;\r\n};\r\n```\r\n`int poll(struct pollfd* fds,nfds_t nfds,int timeout);`   \r\n\r\n函数参数：　　　\r\n\r\n* 参数一：表示一个pollfd结构的数组，用来保存想要监听的文件描述符及其注册（绑定）的相应事件\r\n\r\n* 参数二：表示监听事件集合的大小\r\n\r\n* 参数三：指定poll的超时值，当timeout为-1的时候，就会一直阻塞，直到某个事件发生，当为0的时候表示立即返回\r\n\r\n返回值：   \r\n当为-1的时候表示失败，当为0的时候表示超时，当为大于0的整数的时候表示执行成功，表示文件描述符的个数\r\n\r\n\r\npoll的编程实例:\r\n\r\n```c\r\nstruct pollfd fds[10]={0};\r\nfds_init(fds);\r\nfds_add(fd,fds,POLLIN);\r\n\r\nwhile(1)\r\n{\r\n    int n=poll(fds,10,-1);\r\n    assert(-1!=n);\r\n    if(fds[i].revents &POLLRDHUP)\r\n    {\r\n         fds_del(fds[i],fds);\r\n         continue;\r\n    }\r\n    int i=0;\r\n\r\n    for(;i<10;++i)\r\n   {\r\n     if(fds[i].revents &POLLIN)\r\n    {\r\n        if(fds[i].fd ==fd)\r\n       {\r\n\t   int c=accept(fd,(struct sockaddr*)&ca,&len);\r\n           if(c>0)\r\n\t   {\r\n       fds_add(c,fds,POLLIN|POLLRDHUP);\r\n\t    }\t\t\r\n        }\r\n\r\n        else\r\n\t{\r\n\t    char buff[128]={0};\r\n   进行读写操作\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\n}\r\n```\r\n\r\n总结：     \r\npoll的特点：   \r\n  首先和select的区别是：没有了最大文件描述符范围的规定了，而且和select相比，不再需要三个fd_set 的指针，只需要使\r\n  用一个 struct pollfd的指针即可    \r\n\r\n  在然后就是由于每次调用select的时候在返回的时候都会对fdset集合进行修改，所以每次调用select的时候都要对fdset集合\r\n  进行FD_ZERO（），然后在把其文件描述加载到fdset集合中去，再然后调用select（即：监听我所设置文件描述符的所有相应\r\n  读事件），poll在这点上做了一定的优化采用了struct pollfd    \r\n```  \r\n{\r\n    int  fd；\r\n    short  events；\r\n    short  revents；\r\n}；\r\n```\r\nevents来告诉poll监听fd上的那些事件，而revents是内核修改的，用来通知应用程序fd上实际发生的事件，从而避免了反复的\r\n对集合的清零与重置    \r\n\r\n三．epoll的编程\r\n====\r\n```\r\n#include<sys/epoll.h>\r\n```\r\n\r\n* 一：用于创建事件表  \r\n```\r\nint epoll_create(int size);    \r\n```\r\n参数一：size 并不起作用，只是给内核一个提示，说创建多大一个事件表     \r\n返回值：表示事件表的文件描述符   \r\n\r\n\r\n* 二：用于操作事件表     \r\n```\r\nint epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)\r\n```\r\n  * 参数一：epfd表示事件表的文件描述符     \r\n\r\n  * 参数二：何种操作    \r\nEPOLL_CTL_ADD      \r\nEPOLL_CTL_MOD//进行修改原有文件描述符上的事件    \r\nEPOLL_CTL_DEL    \r\n\r\n  * 参数三：要操作的文件描述符    \r\n\r\n  * 参数四：指定事件      \r\n\r\n```\r\nstruct  epoll_event\r\n{\r\n   int events;\r\n   epoll_data_t data;//是一个union\r\n\r\n};\r\n```    \r\n返回值：成功为0  失败-1     \r\n\r\n* 三：监听相应事件      \r\n\r\n```\r\nint epoll_wait(int epfd,struct epoll_event *events ,int maxevents,int timeout)\r\n```  \r\n\r\n参数二：当有相应的事件发生时，会把事件表中的放到events当中去      \r\n\r\n\r\n返回值：当为-1的时候表示失败，当为0的时候表示超时，当为大于0的整数的时候表示执行成功，表示文件描述符的个数     \r\n\r\n\r\nepoll的特点：      \r\n\r\n  首先epoll达到了O（1）的时间复杂度，epoll把用户关心的文件描述符和想要监听的事件放在了内核的一张事件表中，而不必\r\n要每次都要传入（文件描述符集和事件集）这样就不像select与poll那样每次都要把文件描述从用户态考到内核态（相对提高\r\n了效率，实际上是通过共享内存实现的），之所以在达到了O（1）的时间复杂度是因为：在调用epoll_wait函数的时候只会把\r\n就绪的事件从事件表中考到events当中去（其实是通过回调函数自己实现的）       \r\n\r\n\r\n其实epoll所采用就是一种分治法的思想，达到了各层的相互独立，比如使用epoll_create来创建事件表从而避免了select与poll\r\n的缺点（每次都要从用户空间把相应的文件描述符拷到内核空间去）      \r\n\r\n注意：有关epoll的两种模式（LT ET）         \r\n\r\n* LT模式（电平触发）特点：当epoll_wait检测到某个文件描述符上的事件发生的时候，应用程序可以不立刻来处理他，当下次调\r\n用epoll_wait的时候还会再次响应次描述符上的此事件     \r\n\r\n* ET模式（边沿触发）特点：意思就是当某个描述符上有事件发生的时候只会通知应用程序一次，之后再不会通知，所以：在使用ET\r\n模式的时候就要使用while循环来读取数据（所以还有设置文件描述符为非阻塞的）避免在循环读取的时候造成阻塞    \r\n\r\n* ET要比LT模式好：原因是在ET模式下减少了epoll事件的触发次数.   \r\n\r\n注意：       \r\n　　　有时候epoll不一定比select和poll的效率高，比如这样的场景下：当活动连接数比较高的时候此时epoll会经常触发回调函数\r\n，此时在性能上还是有一定的损失．epoll适用于连接数量多，但是活跃的连接少．       \r\n\r\n　　　\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"linux select poll epoll ","note":"Don't delete this file! It's used internally to help with page regeneration."}